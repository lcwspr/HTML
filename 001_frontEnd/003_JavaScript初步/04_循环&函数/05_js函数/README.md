# 函数初步
## 整体感知
1. 多条语句组合而成的一个语句的军团，集体作战。
2. 定义一个函数，要使用关键字function, function就是英语功能的意思
    * 表示这里面定义的语句，完成了一些功能，function后面有一个空格，后面就是函数的名字，函数的名字也是关键字，命名规范和变量的规范是一样的
    * 名字后面有一对圆括号，里面放置参数，然后就是大括号，大括号里面是函数的语句
    * 函数如果不调用，那么里面的语句永远不会执行： 函数的执行: `funName()`, 
    * 再出现大量程序相同的时候，就可以封装成为一个function： 这样只用调用一次，就能够执行很多语句
    
## 函数的参数
* 定义在函数内部的语句，都是相同的，但是实际上我们可以通过"参数"这个东西，来让语句有细微的差别
* 罗列在function小括号中的参数，叫做形式参数，调用时传递的数值，叫做实际参数 

## 函数的返回值
* 函数有一个return的值，那么现在这个函数，实际上就是一个表达式，换句话说就是一个值，所以这个函数，可以当作其他函数的参数
    * 函数可以接受很多值，返回一个值
    * 函数的意义: 模块化编程，让复杂的逻辑变得简单 
* 例子
    1. 我们要做一个程序，输出200以内的所有的质数，所谓的质数，就是只有1，自己两个的约数，没有其他的约数，要把一个复杂的问题拆分为一个个小问题
        1. 有一个函数能够找出他约数的个数
            ```
            function findYueShu(a){
                var count = 0; 
                for(var i = 1; i <= a; i++){
                    if(a % i == 0){
                        count ++;
                    }
                }
                return count;    // 返回这个数字约数的个数
            }
            function isZhi(m){
                return (findYueShu(m) == 2 ? true: false;
            }
            for(var i = 0; i < 100; i++){
                console.log(isZhi(i));
            }
            ```
    2. 任何一个偶数，都可以拆分为两个质数的和。现在我们要求，用户输入一个偶数，把所有的质数拆分可能写出来
        ```
        var num = inputNum;
        for(var i = 1; i < num; i++){
            if(isZhi(i) && isZhi(num - i)){
                console.log(i + "   " + (num - i));
            }
        }
        ```
    3. 将2-1000000的所有偶数拆分为两个质数的和，只要拆一个结果就好了，比如48有多种拆法，只需要一种
    4. 如果整数A的全部约数(包括1， 不包括A本身)之和等于B，且整数B的全部约数(包括1, 不包括B本身)之和等于A， 则称整数A和B是一对亲密数， 求3000以内的全部亲密数
    
## 递归
* 函数可以自己调用自己，这就是递归
* 斐波那契数列
    ```
    fib(n) = fib(n -1) + fib(n-2)
    function fib(n){
        if(n <= 2)
            return 1;
        return fib(n - 1) + fib(n - 2);
    }
    ```

## 函数表达式
1. 函数表达式
    * 定义函数除了使用function之外，还有一种方法，就是函数表达式，就是函数没有名字，称之为"匿名函数", 为了今后能够调用它，我们把这个匿名函数，直接赋值给一个变量
    ```
    var haha = function(){
        return a + b;
    }
    ```
    * 但是如果使用函数表达式定义函数，如果有名字，那么函数名只能在函数体内使用，倘若在函数体外使用函数名将会导致错误
        * 这就是js的一个语法特性，也就是说： 定义函数只能使用这两种中的一种，不能杂糅
   
## 函数声明的提升(预解析)
* 函数声明头可以提升，js程序执行之前，都会有一个函数预解析阶段，预解析阶段是自动进行的
    * 函数的声明会被提升，但是函数表达式却不会被提升
    * 函数优先，函数声明和变量声明都会被提升，但是 ***函数会被首先提升，然后才是变量*** 
    * 函数声明的提升，无视if等语句的判断，强制提升
* 例题
    1. 函数优先
        1. 例子一
        ```
        aaa();
        var aaa = 5;  // 定义一个变量，是5
        function aaa(){
            alert("我是一个函数，哈哈哈")
        }
        ```
        2. 例子二
        ```
        var aaa = 5;
        function aaa(){
            alert("我是aa函数，我执行了")
        }
        aaa();   // 会报错
        ```
    2. 例题1
        ```
        foo();         // 弹出1
        var foo;
        function foo(){ console.log(1); } 
        foo = function(){ console.log(2); }
        ```
        * 函数优先，现在foo这个标识符冲突了，一个函数叫做foo,一个变量也叫做foo，预解析阶段，如果遇见标识符冲突，这个标识符给函数 
 
## 函数是一个引用类型
* 我们之前说的，基本数据类型： number, string, boolean, undefined, null
* 引用数据类型有好多种，function就是一种。
    * `function fun(){}; alert(typeof fun);` # function
* ***基本类型保存值，引用类型保存地址***
    1. 我们的变量a=6, 那么这个a变量里面存储的是6这个数值。
    2. 而a=function(){}, 那么这个a标签里面存储的是function的内存地址
* 常见对象
    1. Object
    2. Function
    3. array
    4. RegExp
    5. Math
    6. Date
 